<!DOCTYPE html>
<html lang="en">

<head>
<link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAwAAAAMCAIAAADZF8uwAAAAGUlEQVR4nGNkYKjnYuDCj5gYiACjiuitCABd0QFzKr1RFgAAAABJRU5ErkJggg=="/>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Thread Cutter</title>
    <style>
body {
    font-family: Arial, sans-serif;
    background-color: #f4f4f4;
    color: #454d59;
    padding: 20px;
    max-width: 600px;
    margin: 0 auto;
    overflow-x: hidden;
}

textarea, #skeetsDisplay {
    box-sizing: border-box;
}

textarea {
    width: 100%;
    min-height: 200px;
    padding: 10px;
    margin-bottom: 10px;
    border: 1px solid #74b8f9;
    border-radius: 5px;
    transition: box-shadow 0.3s, border-color 0.3s;
}

textarea:focus {
    box-shadow: 0 0 10px rgba(17, 111, 253, 0.2);
    border-color: #1b79f3;
}

button {
    background-color: #1b79f3;
    color: #f4f4f4;
    padding: 10px 15px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.3s;
    position: relative; 
}

button:hover {
    background-color: #679cec;
    transform: scale(1.05);
}

button:active {
    background-color: #454d59;
    transform: scale(1);
}

select {
    margin-left: 10px;
    padding: 9px 12px;
    border: 1px solid #74b8f9;
    border-radius: 5px;
    transition: box-shadow 0.3s, border-color 0.3s;
    cursor: pointer;
    outline: none;
}

select:focus {
    box-shadow: 0 0 10px rgba(17, 111, 253, 0.2);
    border-color: #1b79f3;
}

#skeetsDisplay {
    margin-top: 20px;
    max-height: 60vh;
    overflow-y: auto;
    border: 1px solid #74b8f9;
    padding: 10px;
    border-radius: 5px;
    box-shadow: 0 2px 4px rgba(59, 67, 79, 0.1);
}

button[data-tooltip]:hover:after, label[data-tooltip]:hover:after {
    content: attr(data-tooltip);
    background-color: #454d59;
    color: #f4f4f4;
    padding: 5px 8px;
    border-radius: 5px;
    position: absolute;
    bottom: 100%; 
    right: 0; 
    margin-bottom: 5px; 
    font-size: 0.8rem;
    pointer-events: none;
    z-index: 10; 
    max-width: 200px; 
    white-space: normal;
    overflow: visible; 
    text-align: left;
}

.skeet {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: center;
    border: 1px solid #74b8f9;
    padding: 10px;
    margin-top: 10px;
    transition: opacity 0.5s;
    background-color: #f2ebf3;
    border-radius: 5px;
}

.skeet-inner {
    flex-grow: 1;
    display: flex;
    flex-direction: column;
}


.skeet .copy {
    margin-left: 10px;
    background-color: #454d59;
    flex-shrink: 0;
}

.skeet-content {
    flex-grow: 1;
    word-break: break-word;
    overflow-wrap: break-word;
}

.dark-mode {
    background-color: #2c2c2c;
    color: #f4f4f4;
}

.dark-mode textarea,
.dark-mode select {
    border-color: #666;
    background-color: #3a3a3a;
    color: #f4f4f4;
}

.dark-mode textarea:focus,
.dark-mode select:focus {
    box-shadow: 0 0 10px rgba(240, 240, 240, 0.2);
    border-color: #888;
}

.dark-mode #skeetsDisplay {
    border-color: #666;
    background-color: #3a3a3a;
    color: #f4f4f4;
}

.dark-mode .skeet {
    border-color: #666;
    background-color: #454545;
}

.dark-mode .copy {
    background-color: #f4f4f4;
    color: #2c2c2c;
}

.dark-mode button {
    background-color: #454d59;
    color: #f4f4f4;
}

::-webkit-scrollbar {
    width: 12px; 
}

::-webkit-scrollbar-track {
    background: #f1f1f1; 
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: #888; 
    border-radius: 10px;
    border: 3px solid #f1f1f1; 
}

::-webkit-scrollbar-thumb:hover {
    background: #555; 
}

body.dark-mode::-webkit-scrollbar-track {
    background: #444; 
}

body.dark-mode::-webkit-scrollbar-thumb {
    background: #aaa; 
    border: 3px solid #444; 
}

body.dark-mode::-webkit-scrollbar-thumb:hover {
    background: #777; 
}

@keyframes magicSparkle {
    0% {
        transform: scale(0.9);
        opacity: 0.5;
    }
    50% {
        transform: scale(1.1);
        opacity: 1;
    }
    100% {
        transform: scale(1);
        opacity: 0.5;
    }
}

.magic-effect {
    animation: magicSparkle 0.5s ease forwards;
}

.copy.copied {
    background-color: #4CAF50;
    color: #f4f4f4;
}

.dark-mode .copy.copied {
    background-color: #66BB6A;
    color: #2c2c2c;
}

.selectors-container {
    display: inline-flex;
    align-items: center;
    gap: 10px;
    margin-left: 5px;
}

.language-container {
    display: inline-flex;
    align-items: center;
    gap: 10px;
}

#threadIndicatorDropdown {
    display: inline-block;
}

label[data-tooltip] {
    position: relative;
    display: inline-block;
    cursor: help;
}

.dark-mode #postThreadButton {
    background-color: #FF8C00;
}

.dark-mode #loginPopup {
    background-color: #2c2c2c;
}

#segmentButton, #cleanButton, #postThreadButton {
    margin-right: 5px;
}

input[type="checkbox"] {
    vertical-align: left;
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.5);
}

.modal-content {
    background-color: #fefefe;
    margin: 10% auto;
    padding: 30px;
    border: none;
    width: 40%;
    max-width: 400px;
    box-shadow: 0 10px 20px 0 rgba(0,0,0,0.3);
    position: relative;
    border-radius: 12px;
    text-align: center;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}

.close-button {
    color: #aaa;
    float: right;
    font-size: 30px;
    font-weight: bold;
    cursor: pointer;
    position: absolute;
    top: 10px;
    right: 15px;
}

.close-button:hover,
.close-button:focus {
    color: #444;
    text-decoration: none;
    cursor: pointer;
}

input[type="text"], input[type="password"] {
    width: 100%;
    padding: 12px 15px;
    margin: 15px 0;
    border: 1px solid #aaa;
    border-radius: 8px;
    transition: border-color 0.3s, box-shadow 0.3s;
    max-width: 90%;
}

input[type="text"]:focus, input[type="password"]:focus {
    border-color: #1b79f3;
    box-shadow: 0 0 10px rgba(17, 111, 253, 0.2);
}



.login-button {
    display: block;
    margin: 20px auto;
    padding: 12px 20px;
    border: none;
    background-color: #1b79f3;
    color: #fff;
    border-radius: 8px;
    cursor: pointer;
    transition: background-color 0.3s, transform 0.3s;
}

.login-button:hover {
    background-color: #157ab5;
    transform: scale(1.05);
}

.dark-mode .modal-content {
    background-color: #2c2c2c;
    color: #f4f4f4;
}

.dark-mode .close-button {
    color: #bbb;
}

.dark-mode input[type="text"], .dark-mode input[type="password"] {
    background-color: #3a3a3a;
    color: #f4f4f4;
    border-color: #555;
}

.dark-mode input[type="text"]:focus, .dark-mode input[type="password"]:focus {
    border-color: #679cec;
    box-shadow: 0 0 10px rgba(103, 156, 236, 0.2);
}

.dark-mode .login-button {
    background-color: #454d59;
}

.dark-mode .login-button:hover {
    background-color: #353b45;
}

@keyframes modalOpen {
    from {
        opacity: 0;
        transform: translateY(-50%);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

@keyframes modalClose {
    from {
        opacity: 1;
        transform: translateY(0);
    }
    to {
        opacity: 0;
        transform: translateY(-50%);
    }
}

.modal-content {
    animation: modalOpen 0.5s forwards;
}

.modal-exit {
    animation: modalClose 0.5s forwards;
}

.language-container {
    display: flex;
    align-items: center;
}

.language-button {
    max-width: 200px;  /* Maximum width */
    overflow: hidden; /* Hide overflow content */
    white-space: nowrap; /* Prevent text wrapping */
    transition: font-size 0.3s; /* Smooth transition for font size change */
}


#languageSelect {
    border: 1px solid #74b8f9;
    width: 150px;
    margin-left: 10px;
    overflow-y: auto;
    max-height: 150px;
    display: none;
    position: absolute;
    background-color: #fff;
    z-index: 10;
}

.language-dropdown {
    border: 1px solid #74b8f9;
    width: 150px;
    overflow-y: auto;
    max-height: 150px;
    display: none;
    position: absolute;
    background-color: #fff;
    z-index: 10;
    padding: 10px;
}

#languageSelect:focus {
    border-color: #1b79f3;
}

#languageSelect option:checked {
    background-color: #f0f0f0;
}

@media only screen and (max-width: 600px) {
    #languageSelect {
        width: 100%;
    }
}

.dark-mode #languageDropdown {
    border-color: #666;
    background-color: #3a3a3a;
}

.dark-mode #languageButton {
    background-color: #454d59;
    color: #f4f4f4;
}

.dark-mode #languageButton:hover {
    background-color: #353b45;
}

.dark-mode label {
    color: #f4f4f4;
}

#languageSearch {
    margin-bottom: 10px;
    width: 90%;
    padding: 5px;
    border: 1px solid #74b8f9;
    border-radius: 4px;
}

.dark-mode #languageSearch {
    background-color: #3a3a3a;
    color: #f4f4f4;
    border-color: #555;
}


@media only screen and (max-width: 600px) {
    body {
        padding: 10px;
        font-size: 16px;  /* Adjusted for better readability on mobile */
    }

    /* Making input elements and buttons stretch to the full width */
    textarea, select, button, #skeetsDisplay {
        width: 100%;
        margin-right: 0;
        margin-left: 0;
    }

    /* Adjusting the modal to fit better on smaller screens */
    .modal-content {
        width: 90%;
        margin: 20% auto;
    }

    /* Increasing button padding for more comfortable tapping */
    button, .login-button {
        padding: 12px 20px;
    }

    /* Adjusting margins for buttons for better spacing */
    #segmentButton, #cleanButton, #postThreadButton {
        margin-bottom: 10px;
    }

    /* Adjusting the language select dropdown for mobile */
    #languageSelect {
        width: 100%;
        position: relative;
        display: block;
    }

    /* Adjusting container layouts for mobile */
    .selectors-container, .language-container {
        flex-direction: column;
        align-items: stretch;
        gap: 10px;  /* Adding a gap for better spacing */
    }
    
    /* Adjusting dropdowns for mobile */
    .language-dropdown, #threadIndicatorDropdown {
        width: 100%;
        margin-top: 10px;
        border-radius: 5px;
    }
    
    .language-button, #threadIndicatorButton {
        padding-right: 25px; /* Additional space for the dropdown indicator */
        background: none; /* Removing the background for mobile */
    }
    
    /* Adjustments for the checkbox */
    input[type="checkbox"] {
        margin-right: 10px;
        margin-top: 5px; /* Adding a top margin for better spacing */
        background-color: #fff;
        border: 1px solid #74b8f9;
        border-radius: 3px;
        width: 20px;
        height: 20px;
    }
    
    label[for="counterExcludeCheckbox"] {
        display: flex;
        align-items: center;
    }
    
     .selectors-container {
            flex-direction: row; /* Layout items in a row */
            justify-content: space-between; /* Space items apart as much as possible */
            gap: 5px;  /* Slight gap between items */
        }
        
        /* Adjusting dropdowns for mobile */
        .language-dropdown, #threadIndicatorDropdown {
            width: 48%; /* Each takes up roughly half the available width, accounting for the gap */
            margin-top: 5px;
            border-radius: 5px;
        }
        button:not(.copy) {
            width: 100%; /* Full width on mobile */
            margin: 10px 0; /* Some margin to separate them from other elements */
        }
        
       .skeet .copy {
            width: auto; /* Reset to natural width */
            margin: 0;   /* Remove any added margin */
        }
    
}

#logoutLink {
    color: #1b79f3;
    text-decoration: none;
    transition: color 0.3s;
}

#logoutLink:hover {
    color: #679cec;
}

.dark-mode #logoutLink {
    color: #888;
}

#loader {
    border: 8px solid #f3f3f3;
    border-radius: 50%;
    border-top: 8px solid #3498db; /* Blue */
    width: 50px;
    height: 50px;
    animation: spin 1s linear infinite;
    display: none;
    margin: auto;
}

.dark-mode #loader {
    border-top: 8px solid #888;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}

.button-container {
    display: flex;
    flex-direction: column;
    gap: 5px;
    align-items: flex-end;
}

.add-pic-button, .skeet .copy {
    width: 80px;  /* Ensures both buttons are of the same width */
    margin-top: 5px;  /* Adds a gap between the two buttons */
}

.add-pic-button {
    background-color: #FF4500; /* Reddish Orange */
    margin-left: 0;  /* Remove the left margin */
}

.thumbnail-container {
    margin-top: 10px;
    display: flex;
    gap: 5px;
}

.thumbnail {
    position: relative; /* Ensure children with absolute positioning use this as their reference point */
    width: 100px;
    height: 100px;
    overflow: hidden;
    border-radius: 5px;
    border: 1px solid #74b8f9;
    padding: 5px; /* Create padding space for the close button */
}

.thumbnail img {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 5px; /* Make the image rounded */
}

.remove-thumbnail {
    position: absolute;
    top: 2px; /* Moved closer to the top edge */
    right: 2px; /* Moved closer to the right edge */
    background-color: red;
    color: #f4f4f4;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    font-size: 16px;
    line-height: 1;
    z-index: 2; /* Ensure it's on top of the thumbnail image */
}

.dark-mode .thumbnail {
    border-color: #666;
}

.dialog {
    background-color: #f4f4f4;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    max-width: 400px;
    width: 80%;
}

.dark-mode .dialog {
    background-color: #2c2c2c;
    color: #f4f4f4;
}

input[type="text"] {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid #aaa;
    border-radius: 5px;
    margin-bottom: 10px;
    transition: border-color 0.3s, box-shadow 0.3s;
    box-sizing: border-box;
}

input[type="text"]:focus {
    border-color: #1b79f3;
    box-shadow: 0 0 10px rgba(17, 111, 253, 0.2);
}

.dark-mode input[type="text"] {
    background-color: #3a3a3a;
    color: #f4f4f4;
    border-color: #555;
}

.dark-mode input[type="text"]:focus {
    border-color: #679cec;
    box-shadow: 0 0 10px rgba(103, 156, 236, 0.2);
}

.edit-thumbnail {
    position: absolute;
    top: 2px; /* Moved closer to the top edge */
    left: 2px; /* Moved closer to the left edge */
    background-color: green;
    color: white;
    font-size: 18px;
    cursor: pointer;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    text-align: center;
    line-height: 20px;
    user-select: none;
}

.thumbnail {
    position: relative;
}




    </style>



</head>

<body>
<div id="themeToggle" style="position: absolute; top: 20px; left: 20px; cursor: pointer;">üåû</div>
<div style="text-align:center; margin-top:20px;">
    <img src="data:image/png;base64,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" alt="Sky" style="margin-right:10px; width:64px; height:64px;"/>
    <img src="data:image/png;base64,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" alt="Thread" style="width:64px; height:64px;"/>
</div>
    <textarea id="inputText" placeholder="Type your long post here. To divide it into separate sections, insert ## between the parts you want to split."></textarea>
    <div style="text-align:center; margin-top:10px; color: green; font-weight: bold;">
        Try [Unlimited Markdown](http(s)://titl.es or @mentio.ns)
    </div>
    <p id="charCount">0 characters</p>
    <button id="segmentButton" data-tooltip="Click to segment your message into thread">Segment</button>
    <button id="cleanButton" data-tooltip="Click to clear the text area">Clean</button>
    <button id="postThreadButton" style="background-color: #FFA500;" data-tooltip="Click to post the segmented thread to BlueSky">Post</button>
<div class="selectors-container">
    <div class="language-container">
        <button id="languageButton">Choose Language</button>
        <div id="languageDropdown" class="language-dropdown">
            <!-- Options will be dynamically populated -->
        </div>
    </div>
    <select id="threadIndicatorDropdown">
        <option value="default">No emoji</option>
        <option value="üßµ">üßµ</option>
        <option value="‚úâÔ∏è">‚úâÔ∏è</option>
        <option value="üìå">üìå</option>
        <option value="custom">Your own</option>
    </select>
</div>



    
    
    <input type="checkbox" id="excludeCounterCheckbox" style="margin-left: 10px;" checked>
    <label for="excludeCounterCheckbox" data-tooltip="Exclude the segment counter (like 1/n) from each thread segment">üî¢</label>
<div id="loginPopup" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="closeLoginPopup()">&times;</span>
        <h3>Login to BlueSky</h3>
        <input type="text" id="handle" placeholder="Handle (without @)">
        <input type="password" id="appPassword" placeholder="App Password">
        <button type="button" class="login-button" onclick="loginAndStartThreadPosting()">Login</button>
    </div>
</div>

    
    
    <div id="loader"></div>
    <div id="skeetsDisplay"></div>

<script src="https://cdn.jsdelivr.net/npm/browser-image-compression@1.0.13/dist/browser-image-compression.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/grapheme-splitter@1.0.4/index.min.js"></script>

    <script>
    
document.addEventListener('DOMContentLoaded', (event) => {
    const inputText = document.getElementById('inputText');

    inputText.addEventListener('input', function() {
        // Save the current cursor position
        const cursorPosition = inputText.selectionStart;

        let text = inputText.value;

        // Replace multiple spaces with a single space
        text = text.replace(/ +/g, ' ');

        // Limit consecutive newlines to 2
        text = text.replace(/\n{3,}/g, '\n\n');

        // Set the modified text value
        inputText.value = text;

        // Restore the cursor position
        inputText.setSelectionRange(cursorPosition, cursorPosition);
    });
});



let debug = false; // Set to true when debugging
let requestsLog = [];

// Correctly capture the '@' symbol and the subsequent handle.
const mention_regex = /[$|\W](?<handle>@([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)/g;
const url_regex = /(?<url>(https?:\/\/)?(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)*(?:[a-z0-9][a-z0-9-]{0,61}[a-z0-9]\.[a-z]{2,10})([\/\w.-]?[^,\s]*)?)/gi;
const markdown_link_regex = /\[(?<title>[^\]]+)\]\((?<linkOrMention>[^\)]+)\)/g


async function fetchWithLogging(url, options) {
    if (debug) {
        requestsLog.push({
            url: url,
            options: options
        });
    }
    return await fetch(url, options);
}

const DAY_IN_MILLISECONDS = 24 * 60 * 60 * 1000;
const CREDENTIALS_EXPIRATION_TIME = 30 * DAY_IN_MILLISECONDS; // 30 days
const DEFAULT_EXPIRATION_TIME = 2 * DAY_IN_MILLISECONDS; // 2 days

const originalSetItem = localStorage.setItem.bind(localStorage);
const originalGetItem = localStorage.getItem.bind(localStorage);
let shouldStartThreadAfterLogin = true;

localStorage.setItem = function(key, value) {
    const timestampKey = key + "-timestamp";
    originalSetItem.call(localStorage, timestampKey, new Date().getTime());
    return originalSetItem.call(localStorage, key, value);
};

localStorage.getItem = function(key) {
    const timestampKey = key + "-timestamp";
    const savedTimestamp = originalGetItem.call(localStorage, timestampKey);
    const currentTime = new Date().getTime();
    let expirationTime;

    if (key === 'obfuscatedCredentials') {
        expirationTime = CREDENTIALS_EXPIRATION_TIME;
    } else {
        expirationTime = DEFAULT_EXPIRATION_TIME;
    }

    if (!savedTimestamp || currentTime - savedTimestamp > expirationTime) {
        localStorage.removeItem(key);           // Remove the expired data
        localStorage.removeItem(timestampKey);  // Remove its timestamp
        return null; // Return null if the data has expired
    }
    return originalGetItem.call(localStorage, key);
};


function obfuscate(str) {
    const ZERO = '\u200B';  // Zero-width space
    const ONE = '\u200D';   // Zero-width joiner
    
    let result = '';
    
    for (let i = 0; i < str.length; i++) {
        let binStr = str.charCodeAt(i).toString(2).padStart(8, '0');
        for (let bit of binStr) {
            result += (bit === '0') ? ZERO : ONE;
        }
    }
    
    return result;
}

function deobfuscate(str) {
    const ZERO = '\u200B';
    const ONE = '\u200D';
    
    let result = '';
    let charBin = '';
    
    for (let char of str) {
        if (char === ZERO) {
            charBin += '0';
        } else if (char === ONE) {
            charBin += '1';
        }
        
        if (charBin.length === 8) {
            result += String.fromCharCode(parseInt(charBin, 2));
            charBin = '';
        }
    }
    
    return result;
}



let copiedButtons = [];

const themeToggle = document.getElementById('themeToggle');

// Function to set the mode based on the class present on the body
function setModeEmoji() {
    if (document.body.classList.contains('dark-mode')) {
        themeToggle.textContent = 'üåô'; // crescent for dark mode
    } else {
        themeToggle.textContent = 'üåû'; // sun for light mode
    }
}

themeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    setModeEmoji();
    // Save theme preference in localStorage
    if (document.body.classList.contains('dark-mode')) {
        localStorage.setItem('theme', 'dark-mode');
    } else {
        localStorage.removeItem('theme');
    }
});




// On page load, set the mode based on user's OS settings or localStorage if previously set
document.addEventListener('DOMContentLoaded', () => {
    if (localStorage.getItem('theme') === 'dark-mode') {
        document.body.classList.add('dark-mode');
    } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches && !localStorage.getItem('theme')) {
        document.body.classList.add('dark-mode');
    }
    setModeEmoji();

    // Restore the saved input text and emoji choice
    if (localStorage.getItem('savedText')) {
        inputText.value = localStorage.getItem('savedText');
        charCount.innerText = `${inputText.value.length} characters`; // Update the character count
    }
    if (localStorage.getItem('savedEmojiChoice')) {
        threadIndicatorDropdown.value = localStorage.getItem('savedEmojiChoice');
        // Trigger the change event to set the threadIndicatorSymbol
        threadIndicatorDropdown.dispatchEvent(new Event('change'));
    }
    if (localStorage.getItem('savedExcludeCounter') !== null) {
        excludeCounterCheckbox.checked = JSON.parse(localStorage.getItem('savedExcludeCounter'));
    }

});


const INPUT_MAX_LENGTH = 300;
const BUFFER = 10;
const PUNCTUATIONS = [".", "!", "?", "‚Ä¶"];
const BRACKET_PAIRS = {
    '(': ')',
    '[': ']',
    '{': '}'
};

const inputText = document.getElementById('inputText');
const segmentButton = document.getElementById('segmentButton');
const skeetsDisplay = document.getElementById('skeetsDisplay');
const charCount = document.getElementById('charCount');

function copyToClipboard(text, buttonElement) {
    if (navigator.clipboard) {
        navigator.clipboard.writeText(text);
    } else {
        let textArea = document.createElement("textarea");
        textArea.value = text;
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        document.execCommand('copy');
        document.body.removeChild(textArea);
    }
    // Add the magic animation
    buttonElement.classList.add('magic-effect');
    setTimeout(() => {
        buttonElement.classList.remove('magic-effect');
    }, 500);  // 500ms matches the animation duration

    // Mark this button as copied
    buttonElement.classList.add('copied');

    // Remember this button's clicked state in the copiedButtons array
    const index = Array.from(skeetsDisplay.children).indexOf(buttonElement.parentElement);
    if (!copiedButtons.includes(index)) {
        copiedButtons.push(index);
    }
}


function isInsideBrackets(text, index) {
    let stack = [];
    for (let i = 0; i <= index; i++) {
        if (BRACKET_PAIRS[text[i]]) {
            stack.push(text[i]);
        } else if (Object.values(BRACKET_PAIRS).includes(text[i])) {
            if (stack.length === 0 || BRACKET_PAIRS[stack.pop()] !== text[i]) {
                return true; // unmatched closing bracket
            }
        }
    }
    return stack.length !== 0;
}

function isInsideMention(text, index) {
 let matches = [...text.matchAll(mention_regex)];
 for (let match of matches) {
     if (index > match.index && index < (match.index + match[0].length)) {
         return true;
     }
 }
 return false;
}

function isInsideURL(text, index) {
 let matches = [...text.matchAll(url_regex)];
 for (let match of matches) {
     if (index > match.index && index < (match.index + match[0].length)) {
         return true;
     }
 }
 return false;
}

function getSegmentEnd(text, maxLength) {
 let end = maxLength;
 let acceptableMinLength = Math.floor(maxLength * 0.5);
 let inQuote = false;  // For tracking quotation marks

 // Split at a newline within the segment's range
 let lastNewline = text.lastIndexOf('\n', end);
 if (lastNewline > acceptableMinLength && lastNewline <= maxLength) {
     return lastNewline + 1;
 }

 // Find the last suitable punctuation before the segment's range
 let lastPunctuationPos = -1;
 for (let i = end; i >= acceptableMinLength; i--) {
     if (text[i] === '"') inQuote = !inQuote;  // Toggle quote status
     if (!inQuote && PUNCTUATIONS.includes(text[i]) && !isInsideBrackets(text, i) && !isInsideMention(text, i) && !isInsideURL(text, i)) {
         lastPunctuationPos = i;
         break;
     }
 }

 if (lastPunctuationPos > 0) {
     return lastPunctuationPos + 1;
 }

 // Adjust end position if it's inside brackets, mentions, or URLs
 if (isInsideBrackets(text, end) || isInsideMention(text, end) || isInsideURL(text, end)) {
     for (let i = end; i >= acceptableMinLength; i--) {
         if (BRACKET_PAIRS[text[i]]) {
             while (i > 0 && text[i - 1] !== ' ') i--;  // Search backward for a safe breakpoint
             return i;
         }
     }
 }

 // Fallback: Look for the last space as a natural breakpoint
 let lastSpace = text.lastIndexOf(' ', end);
 if (lastSpace > acceptableMinLength) {
     return lastSpace + 1;
 }

 return end;
}


const threadIndicatorDropdown = document.getElementById('threadIndicatorDropdown');
let threadIndicatorSymbol = "";

threadIndicatorDropdown.addEventListener('change', function() {
    let value = this.value;

    if (value === "default") {
        threadIndicatorSymbol = "";
    } else if (value === "custom" || value === "changeEmoji") {
        let customSymbol = prompt("Enter the symbol to use:");

        if (customSymbol) {
            customSymbol = customSymbol.trim();
            
            // customSymbol = customSymbol[0];

            // Check if changeEmoji option already exists, if not create it.
            let changeEmojiOption = Array.from(this.options).find(opt => opt.value === "changeEmoji");
            if (!changeEmojiOption) {
                changeEmojiOption = new Option("Change emoji", "changeEmoji");
                this.add(changeEmojiOption);
            }

            // Locate the custom option and update its text and value
            let customOption = Array.from(this.options).find(opt => opt.value === "custom");

            if (!customOption) {
                customOption = new Option(customSymbol, "custom");  // if it doesn't exist, create it with fixed value 'custom'
                this.add(customOption);
            }

            // Update the custom option's text, but not its value
            customOption.textContent = customSymbol; // Update the visible text

            threadIndicatorSymbol = customSymbol;

            // Set the selected option to the custom option.
            this.value = "custom";

        } else {
            alert("Please enter a valid single symbol.");
            this.value = "default";
        }
    } else {
        threadIndicatorSymbol = value;
    }
    localStorage.setItem('savedEmojiChoice', this.value);
});

let skeetImagesMap = new Map();

async function uploadImage(session, imageDetails) {
    const response = await fetchWithLogging(`${BASE_URL}com.atproto.repo.uploadBlob`, {
        method: 'POST',
        headers: {
            'Content-Type': imageDetails.mimeType,
            'Authorization': `Bearer ${session['accessJwt']}`
        },
        body: imageDetails.data
    });

    if (!response.ok) {
        throw new Error(`Failed to upload image: ${response.statusText}`);
    }

    return response.json();
}

let askForAlt = true;

async function compressImage(file) {
    const options = {
        maxSizeMB: 1e6 / (1024 * 1024),  // approximately 0.97656 MB
        // maxWidthOrHeight: 1920,
        useWebWorker: true,
    };

    try {
        const compressedFile = await imageCompression(file, options);
        return compressedFile; 
    } catch (error) {
        console.error("Error compressing the image: ", error);
        return null;
    }
}

async function stripExif(file) {
    return new Promise((resolve, reject) => {
        let img = new Image();
        let objectURL = URL.createObjectURL(file);
        img.src = objectURL;

        img.onload = function() {
            let canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            let ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);

            let outputType;
            if (['image/jpeg', 'image/png'].includes(file.type)) {
                outputType = file.type;
            } else {
                // Default to JPG if the original format is not PNG or JPG
                outputType = 'image/jpeg';
            }

            canvas.toBlob(blob => {
                URL.revokeObjectURL(objectURL);  // Revoke the object URL after its use
                resolve(new Blob([blob], { type: outputType }));
            }, outputType);
        };

        img.onerror = function() {
            URL.revokeObjectURL(objectURL);  // Revoke the object URL if there's an error
            reject(new Error("Error processing image for EXIF removal"));
        };
    });
}

// Let the picking begin

function handleAddPic(button, skeetDiv) {
    let input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.multiple = true;

    input.onchange = async function() {
        let files = this.files;
        let thumbnailContainer = skeetDiv.querySelector('.thumbnail-container');
        let availableSlots = 4 - thumbnailContainer.children.length;

        if (availableSlots <= 0) {
            alert("No available slots to add more images.");
            return;
        }

        let filesToProcess = Math.min(files.length, availableSlots);

        for (let i = 0; i < filesToProcess; i++) {
            let file = files[i];

            file = await stripExif(file);

            if (file.size > 1000000) {
                file = await compressImage(file);
                if (!file) {
                    alert("Error compressing the image.");
                    continue;
                }
            }

            await new Promise(resolve => {
                let reader = new FileReader();
                reader.onload = async function(e) {
                    let imageDetails = {
                        data: new Blob([e.target.result], { type: file.type }),
                        mimeType: file.type,
                        alt: ''
                    };

                    const altText = await askForAltText(e.target.result, imageDetails.alt);
                    imageDetails.alt = altText;

                    let thumbnail = document.createElement('div');
                    thumbnail.classList.add('thumbnail');

                    let img = document.createElement('img');
                    img.src = URL.createObjectURL(imageDetails.data);
                    thumbnail.appendChild(img);

                    let removeIcon = document.createElement('span');
                    removeIcon.classList.add('remove-thumbnail');
                    removeIcon.innerHTML = '&times;';
                    removeIcon.onclick = function() {
                        thumbnailContainer.removeChild(thumbnail);
                        let skeetID = skeetDiv.id;
                        let images = skeetImagesMap.get(skeetID) || [];
                        let index = images.indexOf(imageDetails);
                        if (index !== -1) {
                            images.splice(index, 1);
                        }
                        skeetImagesMap.set(skeetID, images);
                    };
                    thumbnail.appendChild(removeIcon);

                    let editAltButton = document.createElement('span');
                    editAltButton.innerHTML = '‚úé';  
                    editAltButton.classList.add('edit-thumbnail');  
                    editAltButton.onclick = async function() {
                        const altText = await askForAltText(e.target.result, imageDetails.alt);
                        imageDetails.alt = altText;
                    };
                    thumbnail.appendChild(editAltButton);

                    thumbnailContainer.appendChild(thumbnail);
                    let skeetID = skeetDiv.id;
                    let images = skeetImagesMap.get(skeetID) || [];
                    images.push(imageDetails);
                    skeetImagesMap.set(skeetID, images);

                    resolve(); // Resolve the promise to continue to the next file
                };

                reader.readAsArrayBuffer(file);
            });
        }
    };

    input.click();
}



async function segmentText() {
    let inputTextValue = inputText.value;
    let metasegments = inputTextValue.split("##");
    let allSegments = [];
    let currentBytePos = 0;

    for (let metasegmentIndex = 0; metasegmentIndex < metasegments.length; metasegmentIndex++) {
        // Trim the start of the metasegment
        let metasegment = metasegments[metasegmentIndex].trimStart();
        const trimmedLength = getByteLength(metasegments[metasegmentIndex]) - getByteLength(metasegment);
        
        // Apply the byte position adjustment for the trimmed part
        currentBytePos += trimmedLength;

        // Process each metasegment individually
        const { text: processedText, facets } = await parse_facets(metasegment);

        // Adjust for the "##" delimiter in all but the first metasegment
        if (metasegmentIndex > 0) {
            currentBytePos += getByteLength("##");
        }

        let currentIndex = 0;
        while (currentIndex < processedText.length) {
            // Calculate the end of the segment, taking multibyte characters into account
            let segmentEnd = getSegmentEnd(processedText.slice(currentIndex, currentIndex + INPUT_MAX_LENGTH - BUFFER), INPUT_MAX_LENGTH - BUFFER);
            let segment = processedText.slice(currentIndex, currentIndex + segmentEnd);
            
            if (!segmentEnd || !segment) {
                alert('Unable to segment the text properly. Please check the input.');
                break;
            }
            
            // Calculate the byte length of the segment
            let segmentByteLength = getByteLength(segment);
            allSegments.push({
                segment: segment,
                byteStart: currentBytePos,
                byteEnd: currentBytePos + segmentByteLength,
                // Additional data for each segment, e.g., facets relevant to this segment
            });

            // Update the current byte position for the start of the next segment
            currentBytePos += segmentByteLength;

            // Move to the next segment
            currentIndex += segmentEnd;
        }
    }

    renderSegments(allSegments);
}





const excludeCounterCheckbox = document.getElementById('excludeCounterCheckbox');

excludeCounterCheckbox.addEventListener('change', () => {
    localStorage.setItem('savedExcludeCounter', excludeCounterCheckbox.checked); // Save the current state of the checkbox
});

let lastSegmentedContent = '';
let lastThreadIndicatorSymbol = '';
let lastExcludeCounterState = false;

function weightedLevenshteinDistance(str1, str2) {
    if (str1 === str2) return 0;
    if (str1.length === 0) return str2.length;
    if (str2.length === 0) return str1.length;

    let matrix = [];

    for (let i = 0; i <= str2.length; i++) {
        matrix[i] = [i];
    }

    for (let j = 0; j <= str1.length; j++) {
        matrix[0][j] = j;
    }

    for (let i = 1; i <= str2.length; i++) {
        for (let j = 1; j <= str1.length; j++) {
            let substitutionCost = (str1.charAt(j - 1) === str2.charAt(i - 1)) ? 0 : 2; // Increased weight for substitutions
            matrix[i][j] = Math.min(matrix[i - 1][j - 1] + substitutionCost, 
                                    matrix[i][j - 1] + 1, 
                                    matrix[i - 1][j] + 1);
        }
    }

    return matrix[str2.length][str1.length];
}

function similarityScore(str1, str2) {
    let distance = weightedLevenshteinDistance(str1, str2);
    let maxLength = Math.max(str1.length, str2.length);
    let score = (maxLength - distance) / maxLength;

    // Bonus for common prefix or suffix
    // let prefixLength = 0;
   // while (prefixLength < str1.length && prefixLength < str2.length && str1[prefixLength] === str2[prefixLength]) {
       // prefixLength++;
   // }
    // score += prefixLength / (2 * maxLength); // Adjust this bonus as needed

    return Math.min(score, 1); // Ensure the score remains between 0 and 1
}

function renderSegmentWithFacets(segment, byteStart, byteEnd, facets) {
    let renderedText = '';
    let currentBytePos = byteStart;
    let graphemeSplitter = new GraphemeSplitter();
    let graphemes = graphemeSplitter.splitGraphemes(segment);
    let byteSizes = graphemes.map(char => getByteSize(char));
    let currentIndex = 0;

    function getByteSize(str) {
        return new TextEncoder().encode(str).length;
    }

    while (currentIndex < graphemes.length) {
        const facet = facets.find(f => currentBytePos >= f.index.byteStart && currentBytePos < f.index.byteEnd);

        if (facet) {
            const facetLength = facet.index.byteEnd - currentBytePos;
            let facetText = '';
            let accumulatedByteSize = 0;

            while (accumulatedByteSize < facetLength && currentIndex < graphemes.length) {
                const currentChar = graphemes[currentIndex];
                const currentCharSize = byteSizes[currentIndex];
                
                if (accumulatedByteSize + currentCharSize <= facetLength) {
                    facetText += currentChar;
                    accumulatedByteSize += currentCharSize;
                    currentIndex++;
                } else {
                    break;
                }
            }

            if (facet.features[0]["$type"] === "app.bsky.richtext.facet#link") {
                renderedText += `<a href="${facet.features[0].uri}" target="_blank" rel="noopener noreferrer">${facetText}</a>`;
            } else if (facet.features[0]["$type"] === "app.bsky.richtext.facet#mention") {
                renderedText += `<a href="https://bsky.app/profile/${facet.features[0].did}" target="_blank" rel="noopener noreferrer">${facetText}</a>`;
            }

            currentBytePos = facet.index.byteEnd;
        } else {
            renderedText += graphemes[currentIndex];
            currentBytePos += byteSizes[currentIndex];
            currentIndex++;
        }
    }

    return renderedText;
}



function recreateOriginalMarkdown(segment, byteStart, byteEnd, facets) {
    let originalText = '';
    let currentBytePos = byteStart;
    let graphemeSplitter = new GraphemeSplitter();
    let graphemes = graphemeSplitter.splitGraphemes(segment);
    let byteSizes = graphemes.map(char => getByteSize(char));
    let currentIndex = 0;

    function normalizeUrl(url) {
        return url.replace(/^https?:\/\//, '');  // Remove 'http://' or 'https://' prefix
    }

    function getByteSize(str) {
        return new TextEncoder().encode(str).length;
    }

    while (currentIndex < graphemes.length) {
        const facet = facets.find(f => currentBytePos >= f.index.byteStart && currentBytePos < f.index.byteEnd);

        if (facet) {
            const facetLength = facet.index.byteEnd - currentBytePos;
            let facetText = '';
            let accumulatedByteSize = 0;

            while (accumulatedByteSize < facetLength && currentIndex < graphemes.length) {
                const currentChar = graphemes[currentIndex];
                const currentCharSize = byteSizes[currentIndex];
                
                if (accumulatedByteSize + currentCharSize <= facetLength) {
                    facetText += currentChar;
                    accumulatedByteSize += currentCharSize;
                    currentIndex++;
                } else {
                    break;
                }
            }

            if (facet.features[0]["$type"] === "app.bsky.richtext.facet#link") {
                if (normalizeUrl(facetText) === normalizeUrl(facet.features[0].uri)) {
                    originalText += facetText;
                } else {
                    originalText += `[${facetText}](${facet.features[0].uri})`;
                }
            } else if (facet.features[0]["$type"] === "app.bsky.richtext.facet#mention") {
                const mention = '@' + resolveDid(facet.features[0].did);
                if (facetText === mention) {
                    originalText += facetText;
                } else {
                    originalText += `[${facetText}](${mention})`;
                }
            }

            currentBytePos = facet.index.byteEnd;
        } else {
            originalText += graphemes[currentIndex];
            currentBytePos += byteSizes[currentIndex];
            currentIndex++;
        }
    }

    return originalText;
}










async function renderSegments(segments) {
    const currentContent = document.querySelector('textarea').value;
    const currentThreadIndicatorSymbol = threadIndicatorSymbol;
    const currentExcludeCounterState = document.getElementById('excludeCounterCheckbox').checked;

    if (lastSegmentedContent === currentContent &&
        lastThreadIndicatorSymbol === currentThreadIndicatorSymbol &&
        lastExcludeCounterState === currentExcludeCounterState) {
        return;
    }

    const { facets } = await parse_facets(currentContent);

    let backupSkeetImagesMap = new Map([...skeetImagesMap.entries()]);
    let oldSkeetContents = Array.from(skeetsDisplay.children);
    skeetImagesMap.clear();

    lastSegmentedContent = currentContent;
    lastThreadIndicatorSymbol = currentThreadIndicatorSymbol;
    lastExcludeCounterState = currentExcludeCounterState;

    skeetsDisplay.innerHTML = '';

    segments.forEach((seg, index) => {
        const segmentFacets = facets.filter(f => f.index.byteStart >= seg.byteStart && f.index.byteEnd <= seg.byteEnd);
        const renderedSegmentForUser = renderSegmentWithFacets(seg.segment, seg.byteStart, seg.byteEnd, segmentFacets);
        const facetlessSegment = recreateOriginalMarkdown(seg.segment, seg.byteStart, seg.byteEnd, segmentFacets);

        let excludeCounter = !document.getElementById('excludeCounterCheckbox').checked;
        let threadIndicator = excludeCounter
            ? (threadIndicatorSymbol ? `${threadIndicatorSymbol} ` : "")
            : (threadIndicatorSymbol ? `${threadIndicatorSymbol} ${index + 1}/${segments.length}\n` : `${index + 1}/${segments.length}\n`);

        let skeetDiv = document.createElement('div');
        let skeetID = `skeet-${Date.now()}-${Math.floor(Math.random() * 1000)}`;
        skeetDiv.id = skeetID;
        skeetDiv.classList.add('skeet');

        let skeetInnerDiv = document.createElement('div');
        skeetInnerDiv.classList.add('skeet-inner');

        let skeetContentDiv = document.createElement('div');
        skeetContentDiv.classList.add('skeet-content');
        skeetContentDiv.innerHTML = `${threadIndicator.replace('\n', '<br>')}${renderedSegmentForUser.replace(/\n/g, "<br>")}`;
        skeetContentDiv.setAttribute('data-facetless', `${threadIndicator}${facetlessSegment}`);
        skeetInnerDiv.appendChild(skeetContentDiv);

        let thumbnailContainer = document.createElement('div');
        thumbnailContainer.classList.add('thumbnail-container');
        skeetInnerDiv.appendChild(thumbnailContainer);

        skeetDiv.appendChild(skeetInnerDiv);

        let bestMatchScore = 0;
        let bestMatchID = null;

        for (let oldSkeetDiv of oldSkeetContents) {
            let oldContent = oldSkeetDiv.querySelector('.skeet-content').getAttribute('data-facetless');
            let score = similarityScore(oldContent, facetlessSegment);
            if (score > bestMatchScore) {
                bestMatchScore = score;
                bestMatchID = oldSkeetDiv.id;
            }
        }

        if (bestMatchID) {
            let images = backupSkeetImagesMap.get(bestMatchID) || [];
            skeetImagesMap.set(skeetID, images);
            backupSkeetImagesMap.delete(bestMatchID);
        } else {
            skeetImagesMap.set(skeetID, []);
        }

        let images = skeetImagesMap.get(skeetID);
        for (let imageDetails of images) {
            let thumbnail = document.createElement('div');
            thumbnail.classList.add('thumbnail');

            let img = document.createElement('img');
            img.src = URL.createObjectURL(imageDetails.data);
            thumbnail.appendChild(img);

            let removeIcon = document.createElement('span');
            removeIcon.classList.add('remove-thumbnail');
            removeIcon.innerHTML = '&times;';
            removeIcon.onclick = function() {
                thumbnailContainer.removeChild(thumbnail);
                let images = skeetImagesMap.get(skeetID) || [];
                let index = images.indexOf(imageDetails);
                if (index !== -1) {
                    images.splice(index, 1);
                }
                skeetImagesMap.set(skeetID, images);
            };
            thumbnail.appendChild(removeIcon);

            let editAltButton = document.createElement('span');
            editAltButton.innerHTML = '‚úé';  
            editAltButton.classList.add('edit-thumbnail');  
            editAltButton.onclick = async function() {
                const altText = await askForAltText(imageDetails.data, imageDetails.alt);
                imageDetails.alt = altText;
            };
            thumbnail.appendChild(editAltButton);

            thumbnailContainer.appendChild(thumbnail);
        }

        // Create a container for the "Copy" and "Add Pic" buttons
        let buttonContainer = document.createElement('div');
        buttonContainer.classList.add('button-container');

        // Create and append the "Copy" button to the button container
        let copyButton = document.createElement('button');
        copyButton.innerText = 'Copy';
        copyButton.classList.add('copy');
        let copyContent = skeetContentDiv.getAttribute('data-facetless');
        copyButton.onclick = function() {
            copyToClipboard(copyContent, this);
        };
        buttonContainer.appendChild(copyButton);

        // Create and append the "Add Pic" button to the button container
        let addPicButton = document.createElement('button');
        addPicButton.innerText = 'Add Pic';
        addPicButton.classList.add('add-pic-button');
        addPicButton.onclick = function() {
            handleAddPic(this, skeetDiv);
        };
        buttonContainer.appendChild(addPicButton);

        // Add the button container to the skeet div
        skeetDiv.appendChild(buttonContainer);

        skeetDiv.style.opacity = '0';
        skeetsDisplay.appendChild(skeetDiv);
        setTimeout(() => {
            skeetDiv.style.opacity = '1';
        }, 100 * index);
    });
}





let counterMode = false;  // Set to true when in counter mode

inputText.addEventListener('input', async () => {
    counterMode = true;  // Enable counter mode
    const result = await parse_facets(inputText.value);
    charCount.innerText = `${result.textLength} characters`;
    counterMode = false;  // Reset counter mode after getting the count
});


inputText.addEventListener('input', () => {
    localStorage.setItem('savedText', inputText.value); // Save the current input text
});

segmentButton.addEventListener('click', segmentText);

function cleanTextArea() {
    // Clear the text area
    inputText.value = '';

    // Reset the character counter
    charCount.innerText = '0 characters';

    // Clear the rendered segments
    skeetsDisplay.innerHTML = '';

    // Remove the saved input text from local storage
    localStorage.removeItem('savedText');

    // Clear backup and other maps or arrays if they exist
    if (backupSkeetImagesMap) backupSkeetImagesMap.clear();
    if (skeetImagesMap) skeetImagesMap.clear();

    // Reset other tracked variables
    lastSegmentedContent = '';
    lastThreadIndicatorSymbol = '';
    lastExcludeCounterState = false;

    // If there are any other global variables or objects that should be cleared,
    // set them to null or reset them here.
}


const cleanButton = document.getElementById('cleanButton');
cleanButton.addEventListener('click', cleanTextArea);

const BASE_URL = 'https://bsky.social/xrpc/';
const JSON_HEADERS = {
    'Content-Type': 'application/json'
};

async function createSession(username, password) {
    console.log('Attempting to create session...');
    const response = await fetchWithLogging(`${BASE_URL}com.atproto.server.createSession`, {
        method: 'POST',
        headers: JSON_HEADERS,
        body: JSON.stringify({
            identifier: username,
            password: password
        })
    });

    if (!response.ok) {
        throw new Error(`Failed to create session: ${response.statusText}`);
    }

    return response.json();
}

async function askForAltText(imageSrc, currentAlt = '') {
    return new Promise((resolve) => {
        // Remove any existing dialog first
        const existingDialog = document.querySelector('.dialog');
        if (existingDialog) {
            document.body.removeChild(existingDialog);
        }

        const dialog = document.createElement('div');
        dialog.style.position = 'fixed';
        dialog.style.top = '50%';
        dialog.style.left = '50%';
        dialog.style.transform = 'translate(-50%, -50%)';
        dialog.style.padding = '20px';
        dialog.style.borderRadius = '5px';
        dialog.style.zIndex = '1000';
        dialog.style.width = '50%';
        dialog.style.maxWidth = '400px';
        dialog.className = 'dialog';

        const imageBlob = new Blob([new Uint8Array(imageSrc)], { type: 'image/jpeg' });
        const imageUrl = URL.createObjectURL(imageBlob);

        dialog.innerHTML = `
            <div style="text-align: center;">
                <img src="${imageUrl}" style="max-width: 100%; max-height: 200px; margin-bottom: 10px; border-radius: 10px;">
            </div>
            <p>Enter alt text for this image:</p>
            <textarea id="altTextInput" style="width: 100%; box-sizing: border-box; height: 100px; resize: none; overflow: auto;">${currentAlt}</textarea>
            <div style="margin-top: 10px;">
                <button id="altTextConfirm" style="width: 100%; margin-bottom: 10px;">Confirm</button>
                <button id="altTextSkip" style="width: 100%;">Skip</button>
            </div>
        `;

        document.body.appendChild(dialog);

        document.getElementById('altTextConfirm').onclick = () => {
            const altText = document.getElementById('altTextInput').value;
            URL.revokeObjectURL(imageUrl);
            document.body.removeChild(dialog);
            resolve(altText);
        };

        document.getElementById('altTextSkip').onclick = () => {
            URL.revokeObjectURL(imageUrl);
            document.body.removeChild(dialog);
            resolve('');
        };
    });
}

function getByteLength(str) {

    return new TextEncoder().encode(str).length;
}




function parse_pattern(text, regex, groupName) {
    let spans = [];
    let m;
    let byteOffset = 0;  // Start with zero offset

    while (m = regex.exec(text)) {
        const matchedGroup = m.groups[groupName];
        const startByteIndex = byteOffset + getByteLength(text.substring(0, m.index)) + getByteLength(m[0]) - getByteLength(matchedGroup);
        const endByteIndex = startByteIndex + getByteLength(matchedGroup);

        spans.push({
            start: startByteIndex,
            end: endByteIndex,
            [groupName]: matchedGroup
        });

        byteOffset += getByteLength(m[0]);
    }
    console.log("Spans:");
    console.log(spans);
    return spans;
}

function parse_mentions(text) {
    return parse_pattern(text, mention_regex, 'handle');
}


function parse_urls(text) {
    return parse_pattern(text, url_regex, 'url');
}


// Cache to store resolved handles and dids
const handleCache = new Map();

async function resolveHandle(handle) {
    // Store the initial value
    const initialShouldStartThreadAfterLogin = shouldStartThreadAfterLogin;

    const obfuscatedCredentials = localStorage.getItem('obfuscatedCredentials');

    handle = normalizeHandle(handle);

    // Check the cache first
    if (handleCache.has(handle)) {
        return handleCache.get(handle);
    }

    try {
        let response = await fetch(`https://bsky.social/xrpc/com.atproto.identity.resolveHandle?handle=${handle}`);
        if (!response.ok) {
            return null; // Handle not resolved
        }

        const did = await response.json();

        // Store in the cache using string representation of did object as the key
        handleCache.set(handle, did);
        console.log("Storing to cache:", {handle, did});
        handleCache.set(JSON.stringify(did), handle);
        
        return did;
    } catch (error) {
        console.error('Error in resolveHandle:', error);
        return null;
    } finally {
        // Reset the value back to its initial state before function exit
        shouldStartThreadAfterLogin = initialShouldStartThreadAfterLogin;
    }
}

function resolveDid(did) {
    // Convert the DID to the stringified format used in the cache
    const didStringified = JSON.stringify({ "did": did });

    // If the cache has this stringified DID, return the corresponding handle
    if (handleCache.has(didStringified)) {
        return handleCache.get(didStringified);
    }

    // If not found in cache, return null
    return null;
}





function normalizeHandle(handle) {
    // If the first character of the handle is '@', remove it.
    handle = handle.startsWith('@') ? handle.substring(1) : handle;

    // Replace commas with a dot.
    handle = handle.replace(/,/g, '.');

    // Remove all percent-encoded sequences.
    handle = handle.replace(/%[0-9A-Fa-f]{2}/g, '');

    // Remove all non-alphanumeric characters, excluding the dot.
    handle = handle.replace(/[^a-zA-Z0-9.]+/g, '');

    // Replace multiple consecutive dots with a single dot.
    handle = handle.replace(/\.{2,}/g, '.');

    // Ensure handle doesn't start or end with a dot.
    handle = handle.replace(/(^\.|\.$)/g, '');

    // Trim off any trailing non-alphanumeric characters, including dots.
    while (/[^a-zA-Z0-9]$/.test(handle)) {
        handle = handle.slice(0, -1);
    }

    // Remove trailing CamelCase.
    const camelCasePattern = /[a-z][A-Z]+$/;
    while (camelCasePattern.test(handle)) {
        handle = handle.replace(camelCasePattern, '');
    }

    // Convert the handle to lowercase.
    handle = handle.toLowerCase();

    return handle;
}




async function parse_facets(text, counterMode = false) {
    let facets = [];
    let positionMappings = [];
    let cleanedText = "";
    let graphemeSplitter = new GraphemeSplitter();
    let graphemes = graphemeSplitter.splitGraphemes(text);
    let i = 0;

    function getByteLength(str) {
        return new TextEncoder().encode(str).length;
    }

    while (i < graphemes.length) {
        try {
            // Handle Markdown links and possible mentions within them
            if (graphemes[i] === '[') {
                let endBracketIndex = graphemes.indexOf(']', i);
                let startParenIndex = graphemes.indexOf('(', endBracketIndex);
                let endParenIndex = graphemes.indexOf(')', startParenIndex);

                if (endBracketIndex > i && startParenIndex > endBracketIndex && endParenIndex > startParenIndex) {
                    const title = graphemes.slice(i + 1, endBracketIndex).join('');
                    let urlOrMention = graphemes.slice(startParenIndex + 1, endParenIndex).join('');

                    // Check if it's a mention in the Markdown link
                    if (urlOrMention.startsWith('@')) {
                        let didResponse;
                        if (urlOrMention.includes('.')) didResponse = await resolveHandle(urlOrMention);
                        if (didResponse && didResponse.did) {
                            positionMappings.push({
                                title: title,
                                url: didResponse.did,
                                isMention: true,
                                originalStart: i,
                                originalEnd: endParenIndex + 1,
                                cleanedStart: cleanedText.length,
                                cleanedEnd: cleanedText.length + title.length
                            });
                        }
                    } else {
                        // Handle as a regular link
                        if (!urlOrMention.startsWith('http://') && !urlOrMention.startsWith('https://')) {
                            urlOrMention = 'http://' + urlOrMention;
                        }
                        positionMappings.push({
                            title: title,
                            url: urlOrMention,
                            isMention: false,
                            originalStart: i,
                            originalEnd: endParenIndex + 1,
                            cleanedStart: cleanedText.length,
                            cleanedEnd: cleanedText.length + title.length
                        });
                    }
                    cleanedText += title;
                    i = endParenIndex + 1;
                    continue;
                }
            }

            // Handle standalone mentions
            if (graphemes[i] === '@') {
                let endOfMentionIndex = graphemes.indexOf(' ', i);
                if (endOfMentionIndex === -1) {
                    endOfMentionIndex = graphemes.length;
                }

                const mention = graphemes.slice(i, endOfMentionIndex).join('');
                if (mention.includes('.')) {
                    // Handle mention with dot
                    let didResponse = await resolveHandle(mention);
                    if (didResponse && didResponse.did) {
                        cleanedText += mention;
                        positionMappings.push({
                            title: mention,
                            url: didResponse.did,
                            isMention: true,
                            originalStart: i,
                            originalEnd: endOfMentionIndex,
                            cleanedStart: cleanedText.length - mention.length,
                            cleanedEnd: cleanedText.length
                        });
                    }
                } else {
                    // Handle mention without dot as regular text
                    cleanedText += mention;
                }

                i = endOfMentionIndex;
                continue;
            }

            cleanedText += graphemes[i];
            i++;
        } catch (error) {
            console.error("An error occurred during parsing:", error);
            i++;
        }
    }

    if (!counterMode) {
        let standaloneUrls = parse_urls(cleanedText); // Ensure parse_urls can handle graphemes
        for (let urlDetail of standaloneUrls) {
            let urlPosition = cleanedText.indexOf(urlDetail.url);
            while (urlPosition !== -1) {
                let urlLength = urlDetail.url.length;

                let isOverlapping = positionMappings.some(mapping => 
                    urlPosition < mapping.cleanedEnd && (urlPosition + urlLength) > mapping.cleanedStart
                );

                if (!isOverlapping) {
                    positionMappings.push({
                        title: urlDetail.url,
                        url: urlDetail.url.startsWith('http://') || urlDetail.url.startsWith('https://') ? urlDetail.url : 'http://' + urlDetail.url,
                        isMention: false,
                        originalStart: urlPosition,
                        originalEnd: urlPosition + urlLength,
                        cleanedStart: urlPosition,
                        cleanedEnd: urlPosition + urlLength
                    });
                }

                urlPosition = cleanedText.indexOf(urlDetail.url, urlPosition + urlLength);
            }
        }

        for (const mapping of positionMappings) {
            const byteStart = getByteLength(cleanedText.substring(0, mapping.cleanedStart));
            const byteEnd = byteStart + getByteLength(mapping.title);

            facets.push({
                index: {
                    byteStart: byteStart,
                    byteEnd: byteEnd
                },
                features: [{
                    "$type": mapping.isMention ? "app.bsky.richtext.facet#mention" : "app.bsky.richtext.facet#link",
                    "uri": mapping.url,
                    "did": mapping.isMention ? mapping.url : undefined
                }]
            });
        }
    }

    return { facets, text: cleanedText, textLength: new GraphemeSplitter().splitGraphemes(cleanedText).length };
}







async function postMessage(session, text, langs, embedImages, threadMetadata = {}) {
console.log('Attempting to post message...');
    
const { facets, text: processedText } = await parse_facets(text);
    
let record = {
    "$type": "app.bsky.feed.post",
    "createdAt": new Date().toISOString(),
    "text": processedText, // Use the processed text
    "langs": langs,
    "facets": facets,
    ...threadMetadata  // Merge threadMetadata directly into record
};

if (embedImages && embedImages.length > 0) {
    record["embed"] = {
        "$type": "app.bsky.embed.images",
        "images": embedImages.map(img => ({
            alt: img.alt,
            image: {
                "$type": "blob",
                "ref": {
                    "$link": img.image.blob.ref.$link
                },
                "mimeType": img.image.blob.mimeType,
                "size": img.image.blob.size
            }
        }))
    };
}

const response = await fetchWithLogging(`${BASE_URL}com.atproto.repo.createRecord`, {
    method: 'POST',
    headers: {
        ...JSON_HEADERS,
        'Authorization': `Bearer ${session['accessJwt']}`
    },
    body: JSON.stringify({
        repo: session['did'],
        collection: 'app.bsky.feed.post',
        record: record
    })
});

if (!response.ok) {
    const responseBody = await response.json();
    console.error('Error response body:', responseBody);
    throw new Error(`Failed to post message: ${response.statusText}`);
}

return response.json();
}



function saveLogsToFile() {
    if (debug) {
        const blob = new Blob([JSON.stringify(requestsLog)], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'requests_log.json';
        a.click();
        URL.revokeObjectURL(url);
    }
}


async function postThread(credentials) {
    const skeets = document.querySelectorAll('.skeet-content');
    console.log("All skeet IDs:", Array.from(skeets).map(s => s.id));
    console.log("Contents of skeetImagesMap:", [...skeetImagesMap.entries()]);

    if (skeets.length === 0) {
        alert('Please segment your message into skeets before posting.');
        return;
    }

    const handle = credentials.handle;
    const appPassword = credentials.appPassword;
    const langs = selectedLanguages;

    if (langs.length === 0) {
        alert('Please select at least one language.');
        return;
    }

    if (langs.length > 3) {
        alert('Please select up to three languages.');
        return;
    }

    const loader = document.getElementById('loader');
    loader.style.display = 'block';

    try {
        const session = await createSession(handle, appPassword);
        let rootMetadata = null;
        let previousPostMetadata = null;

        for (const skeet of skeets) {
            // Use the data-facetless attribute to get the facetless version of the content
            let text = skeet.getAttribute('data-facetless');

            let skeetID = skeet.parentElement.parentElement.id;  
            const images = skeetImagesMap.get(skeetID) || [];
            const embedImages = [];

            for (const imageDetails of images) {
                const blob = await uploadImage(session, imageDetails);
                console.log("Blob received from uploadImage:", blob);
                
                embedImages.push({
                    alt: imageDetails.alt,
                    image: blob
                });
            }
            
            console.log("Embed Images array before post:", embedImages);

            let threadMetadata = {};
            if (previousPostMetadata) {
                threadMetadata.reply = {
                    root: {
                        uri: rootMetadata.uri,
                        cid: rootMetadata.cid
                    },
                    parent: {
                        uri: previousPostMetadata.uri,
                        cid: previousPostMetadata.cid
                    }
                };
            }

            const metadata = await postMessage(session, text, langs, embedImages, threadMetadata);

            // Only set rootMetadata for the first post
            if (!rootMetadata) {
                rootMetadata = {
                    uri: metadata.uri,
                    cid: metadata.cid
                };
            }

            // Update previousPostMetadata after each post
            previousPostMetadata = {
                uri: metadata.uri,
                cid: metadata.cid
            };
        }

        alert("Thread posted successfully!");
        saveLogsToFile();
    } catch (error) {
        console.error('Error:', error);
        alert('Failed to post. Check the browser console for more details.');
        saveLogsToFile();
    } finally {
        loader.style.display = 'none';
    }
}









async function loginAndStartThreadPosting() {
    const handle = document.getElementById('handle').value.trim();
    const appPassword = document.getElementById('appPassword').value.trim();

    // Check if handle and appPassword are provided
    if (!handle || !appPassword) {
        alert("Please enter correct credentials.");
        return;
    }

    const credentials = JSON.stringify({ handle, appPassword });
    const obfuscatedCredentials = obfuscate(credentials);
    
    localStorage.setItem('obfuscatedCredentials', obfuscatedCredentials);
    
    closeLoginPopup();
    displayLogoutLink();

    if (shouldStartThreadAfterLogin) {
        postThread({ handle, appPassword });
    }
}





async function showLoginPopupIfNeeded() {
    const obfuscatedCredentials = localStorage.getItem('obfuscatedCredentials');

    if (obfuscatedCredentials) {
        const decryptedCredentials = deobfuscate(obfuscatedCredentials);
        postThread(JSON.parse(decryptedCredentials));
    } else if (!obfuscatedCredentials) {  // Show login popup only if credentials are not available
        document.getElementById("loginPopup").style.display = "block";
    }
}



function closeLoginPopup() {
    const modalContent = document.querySelector('.modal-content');
    modalContent.classList.add('modal-exit');
    setTimeout(() => {
        document.getElementById("loginPopup").style.display = "none";
        modalContent.classList.remove('modal-exit');  // Reset the class for next use
    }, 500);  // Wait for 500ms (animation duration) before hiding the modal
}

const availableLanguages = [
    { code: 'uk', name: 'Ukrainian' },
    { code: 'en', name: 'English' },
    { code: 'fr', name: 'French' },
    { code: 'es', name: 'Spanish' },
    { code: 'de', name: 'German' },
    { code: 'ru', name: 'Russian' },
    { code: 'it', name: 'Italian' },
    { code: 'pt-PT', name: 'Portuguese (European)' },
    { code: 'pt-BR', name: 'Portuguese (Brazilian)' },
    { code: 'pl', name: 'Polish' },
    { code: 'nl', name: 'Dutch' },
    { code: 'sv', name: 'Swedish' },
    { code: 'no', name: 'Norwegian' },
    { code: 'da', name: 'Danish' },
    { code: 'fi', name: 'Finnish' },
    { code: 'el', name: 'Greek' },
    { code: 'cs', name: 'Czech' },
    { code: 'hu', name: 'Hungarian' },
    { code: 'ro', name: 'Romanian' },
    { code: 'sk', name: 'Slovak' },
    { code: 'sl', name: 'Slovenian' },
    { code: 'hr', name: 'Croatian' },
    { code: 'bg', name: 'Bulgarian' },
    { code: 'sr', name: 'Serbian' },
    { code: 'ar', name: 'Arabic' },
    { code: 'zh-CN', name: 'Chinese (Simplified)' },
    { code: 'zh-TW', name: 'Chinese (Traditional)' },
    { code: 'ja', name: 'Japanese' },
    { code: 'hi', name: 'Hindi' },
    { code: 'bn', name: 'Bengali' },
    { code: 'jv', name: 'Javanese' },
    { code: 'la', name: 'Latin' },
    { code: 'ko', name: 'Korean' },
    { code: 'ms', name: 'Malay' },
    { code: 'tr', name: 'Turkish' },
    { code: 'sw', name: 'Swahili' },
    { code: 'eu', name: 'Basque' },
    { code: 'ca', name: 'Catalan' },
    { code: 'eo', name: 'Esperanto' },
    { code: 'et', name: 'Estonian' },
    { code: 'tl', name: 'Filipino' },
    { code: 'gl', name: 'Galician' },
    { code: 'ka', name: 'Georgian' },
    { code: 'ht', name: 'Haitian Creole' },
    { code: 'he', name: 'Hebrew' },
    { code: 'is', name: 'Icelandic' },
    { code: 'ig', name: 'Igbo' },
    { code: 'id', name: 'Indonesian' },
    { code: 'ga', name: 'Irish' },
    { code: 'km', name: 'Khmer' },
    { code: 'ku', name: 'Kurdish' },
    { code: 'ky', name: 'Kyrgyz' },
    { code: 'lo', name: 'Lao' },
    { code: 'lv', name: 'Latvian' },
    { code: 'lt', name: 'Lithuanian' },
    { code: 'lb', name: 'Luxembourgish' },
    { code: 'mk', name: 'Macedonian' },
    { code: 'mg', name: 'Malagasy' },
    { code: 'ml', name: 'Malayalam' },
    { code: 'mt', name: 'Maltese' },
    { code: 'mi', name: 'Maori' },
    { code: 'mr', name: 'Marathi' },
    { code: 'mn', name: 'Mongolian' },
    { code: 'my', name: 'Myanmar (Burmese)' },
    { code: 'ne', name: 'Nepali' },
    { code: 'ny', name: 'Chichewa' },
    { code: 'ps', name: 'Pashto' },
    { code: 'fa', name: 'Persian' },
    { code: 'st', name: 'Sesotho' },
    { code: 'si', name: 'Sinhala' },
    { code: 'so', name: 'Somali' },
    { code: 'su', name: 'Sundanese' },
    { code: 'tg', name: 'Tajik' },
    { code: 'ta', name: 'Tamil' },
    { code: 'te', name: 'Telugu' },
    { code: 'th', name: 'Thai' },
    { code: 'uk', name: 'Ukrainian' },
    { code: 'ur', name: 'Urdu' },
    { code: 'uz', name: 'Uzbek' },
    { code: 'vi', name: 'Vietnamese' },
    { code: 'cy', name: 'Welsh' },
    { code: 'xh', name: 'Xhosa' },
    { code: 'yi', name: 'Yiddish' },
    { code: 'zu', name: 'Zulu' }
];




const selectedLanguages = [];

// Populate dropdown with available languages
const languageDropdown = document.getElementById('languageDropdown');

const languageButton = document.getElementById('languageButton');

function updateLanguageButton() {
    if (selectedLanguages.length === 0) {
        languageButton.textContent = 'Choose Language';
    } else {
        languageButton.textContent = `${selectedLanguages.join(', ')}`;
    }
}

// Save the selected languages to localStorage
function saveSelectedLanguages() {
    localStorage.setItem('selectedLanguages', JSON.stringify(selectedLanguages));
}

// Populate dropdown with available languages FIRST
availableLanguages.forEach(language => {
    const container = document.createElement('div');
    container.className = 'language-container';

    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = language.code;
    checkbox.value = language.code;
    
    const label = document.createElement('label');
    label.htmlFor = language.code;
    label.textContent = language.name;

    container.appendChild(checkbox);
    container.appendChild(label);
    languageDropdown.appendChild(container);
});

// Load the selected languages from localStorage AFTER populating dropdown
function loadSelectedLanguages() {
    const savedLanguages = JSON.parse(localStorage.getItem('selectedLanguages'));
    if (savedLanguages) {
        savedLanguages.forEach(lang => {
            const checkbox = document.getElementById(lang.toLowerCase());
            if (checkbox) {
                checkbox.checked = true;
                selectedLanguages.push(lang);
            }
        });
        updateLanguageButton();
    }
}

// Call the load function after populating the dropdown
loadSelectedLanguages();

function updateCheckboxAvailability() {
    const checkboxes = languageDropdown.querySelectorAll('input[type="checkbox"]');
    if (selectedLanguages.length >= 3) {
        checkboxes.forEach(checkbox => {
            if (!checkbox.checked) {
                checkbox.disabled = true;
            }
        });
    } else {
        checkboxes.forEach(checkbox => {
            checkbox.disabled = false;
        });
    }
}

updateCheckboxAvailability();



languageButton.addEventListener('click', () => {
    if (languageDropdown.style.display === 'none' || !languageDropdown.style.display) {
        languageDropdown.style.display = 'block';
    } else {
        languageDropdown.style.display = 'none';
    }
});


languageDropdown.addEventListener('change', (event) => {
    const languageName = event.target.value.toUpperCase();
    if (event.target.checked) {
        if (!selectedLanguages.includes(languageName)) {
            selectedLanguages.push(languageName);
        }
    } else {
        const index = selectedLanguages.indexOf(languageName);
        if (index > -1) {
            selectedLanguages.splice(index, 1);
        }
    }
    updateLanguageButton();
    saveSelectedLanguages();
    updateCheckboxAvailability();  // Save to localStorage
});

// Hide the dropdown when clicking outside
document.addEventListener('click', (event) => {
    if (!languageDropdown.contains(event.target) && !languageButton.contains(event.target)) {
        languageDropdown.style.display = 'none';
    }
});

// Create a search input at the top of the dropdown
const searchInput = document.createElement('input');
searchInput.type = 'text';
searchInput.placeholder = 'Search...';
searchInput.id = 'languageSearch';

// Insert the search input at the beginning of the dropdown
languageDropdown.insertBefore(searchInput, languageDropdown.firstChild);

// Filtering function
function filterLanguages() {
    const query = searchInput.value.toLowerCase();
    
    // Get all the containers
    const containers = languageDropdown.querySelectorAll('.language-container');

    containers.forEach(container => {
        const label = container.querySelector('label');
        if (label.textContent.toLowerCase().startsWith(query)) {
            container.style.display = 'block';  // Changed to 'block'
        } else {
            container.style.display = 'none';
        }
    });
}
// Attach the event listener to the search input
searchInput.addEventListener('input', filterLanguages);



document.getElementById("postThreadButton").addEventListener("click", showLoginPopupIfNeeded);

function checkCredentials() {
    const credentials = localStorage.getItem('obfuscatedCredentials');
    if (credentials) {
        displayLogoutLink();
    }
}

function displayLogoutLink() {
    const logoutLink = document.createElement('a');
    logoutLink.href = "#";
    logoutLink.innerText = "Logout";
    logoutLink.id = "logoutLink";
    logoutLink.style.textAlign = "center";
    logoutLink.style.display = "block";
    logoutLink.style.marginTop = "20px";
    logoutLink.style.cursor = "pointer";
    logoutLink.addEventListener('click', handleLogout);

    const skeetsDisplay = document.getElementById('skeetsDisplay');
    skeetsDisplay.insertAdjacentElement('afterend', logoutLink);
}


function handleLogout(event) {
    event.preventDefault();
    localStorage.removeItem('obfuscatedCredentials');
    localStorage.removeItem('obfuscatedCredentials-timestamp');
    const logoutLink = document.getElementById('logoutLink');
    logoutLink.remove();
}

document.addEventListener('DOMContentLoaded', checkCredentials);



    </script>
</body>

</html>
